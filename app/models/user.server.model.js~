var mongoose = require('mongoose'),
    crypto = require('crypto'),
    Schema = mongoose.Schema;
    
//Creates the schema for a user include information fields
var UserSchema = new Schema({

	firstName: String,

	lastName: String,

	email: {
		type: String,
		//index allows for a secondary index or key
		index: true,

//regex expression to match a valid email address such as name@example.com
		match: [/.+\@.+\..+/, "Please fill a valid e-mail address"]
	},

	username: {
		type:String,
		// trim clears leading and trailing whitespace
		trim: true,
		// unique allows username to be the unique index or primary key sort of
		unique: true,
		required: 'Username is required'
	},

	password: {
		type: String,
		//validate allows for a customizable validator; in this case, forces the password field to be 6 characters or longer
		validate: [
			function(password) {
				return password && password.length >= 6;
		}, 'Password should be longer'
		]
	},
	
	salt: {

		type: String
	
	},

	provider: {
		
		type: String,
		required: 'Provider is required'
	},

	providerId: String,
	providerData: {},

	created: {
		type: Date,
		default: Date.now
	}, 

	role: {
		type: String,
		//enum allows the role to be only Admin, Owner, or User
		enum: ['Admin', 'Owner', 'User']
	},
	//website allows the url to have http if not already
	website: {
		type: String,
		get: function(url) {
			if (!url) {
				return url;
			}
			else {
				if ( url.indexOf('http://') !== 0 && url.indexOf('https://') !== 0) {
					url = 'http://' + url;
		    }

			return url;
			     
				}
			}
	},
	
});

//Virtual attribute to create a fullname by finding and using the first and last name; also breaks apart full name
UserSchema.virtual('fullName').get(function() {

	return this.firstName + ' ' + this.lastName;
})
				     .set(function(fullName) {
					var splitName = fullName.split(' ');
					this.firstName = splitName[0] || '';
					this.lastName = slitName[1] || '';
});

 UserSchema.pre('save', function(next) {
      if (this.password && this.password.length > 6) {
        this.salt = new Buffer(crypto.randomBytes(16).toString('base64'), 'base64');
        this.password = this.hashPassword(this.password);
      }

      next();
    });
  
  UserSchema.methods.hashPassword = function(password) {
   if (this.salt && password) {
        return crypto.pbkdf2Sync(password, this.salt, 10000, 64).toString('base64');
    } else {
        return password;
    }
};
/*
UserSchema.pre('save', function(next) {
	if (this.password) {

		this.salt = new
		Buffer(crypto.randomBytes(16).toString('base64'), 'base64');
		this.password = this.hashPassword(this.password);
	}
	next();
});

UserSchema.methods.hashPassword = function(password) {

return crypto.pbkdf2Sync(password, this.salt, 10000, 64).toString('base64');

};
*/
UserSchema.methods.authenticate = function(password) {
	return this.password === this.hashPassword(password);
};

UserSchema.statics.findUniqueUsername = function(username, suffix, callback) {
	
	var _this = this;
	var possibleUsername = username + (suffix || '');

	_this.findOne({
		username: possibleUsername
	}, function(err, user) {
	if(!err) {
			
		if(!user) {
			
			callback(possibleUsername);
		}
		
		else{

	return _this.findUniqueUsername(username, (suffix || 0 ) + 1, callback);
	
		}

	} else {
		
		callback(null);
		
		}

	});
};

UserSchema.set('toJSON', {
	getters: true, 
	virtuals: true 
});

mongoose.model('User', UserSchema);
